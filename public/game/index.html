<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Car Parking Puzzle - Jakhabitat Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            border: 3px solid #2d3436;
            border-radius: 10px;
            background: #27ae60;
            cursor: pointer;
        }
        #instructions {
            color: white;
            text-align: center;
            font-size: 16px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #controls {
            color: white;
            text-align: center;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <div>üöó CAR PARKING PUZZLE üÖøÔ∏è</div>
        <div>Keluarkan semua mobil dari area parkir!</div>
    </div>
    <canvas id="gameCanvas" width="900" height="700"></canvas>
    <div id="controls">
        <div>KLIK & DRAG mobil untuk menggerakkan | R untuk restart</div>
        <button id="backToSelector" style="margin-top: 10px; background: #e74c3c; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">‚Üê Kembali ke Game Center</button>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let level = 1;
        let selectedCar = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let carsExited = [];

        // Grid system
        const GRID_SIZE = 70;
        const GRID_WIDTH = 10;
        const GRID_HEIGHT = 8;
        const OFFSET_X = 100;
        const OFFSET_Y = 100;

        // Car data
        let cars = [];
        let obstacles = [];
        let carImages = {};
        let imagesLoaded = 0;
        let totalImages = 6;
        
        // Auto-detect car images
        function loadCarImages() {
            // Try to load up to 20 car images
            const possibleFiles = [
                'pngegg.png',
                'pngegg (1).png', 
                'pngegg (2).png',
                'pngegg (3).png',
                'pngegg (4).png',
                'pngegg (5).png',
                'pngegg (6).png',
                'pngegg (7).png',
                'pngegg (8).png',
                'pngegg (9).png',
                'pngegg (10).png',
                'pngegg (11).png',
                'pngegg (12).png',
                'pngegg (13).png',
                'pngegg (14).png',
                'pngegg (15).png',
                'pngegg (16).png',
                'pngegg (17).png',
                'pngegg (18).png',
                'pngegg (19).png'
            ];
            
            let loadedCount = 0;
            let validImages = 0;
            
            possibleFiles.forEach((file, index) => {
                const img = new Image();
                img.onload = () => {
                    carImages[validImages] = img;
                    validImages++;
                    loadedCount++;
                    if (loadedCount === possibleFiles.length) {
                        totalImages = validImages;
                        console.log(`Loaded ${validImages} car images`);
                        generateLevels();
                        initLevel();
                        gameLoop();
                    }
                };
                img.onerror = () => {
                    loadedCount++;
                    if (loadedCount === possibleFiles.length) {
                        totalImages = validImages;
                        console.log(`Loaded ${validImages} car images`);
                        generateLevels();
                        initLevel();
                        gameLoop();
                    }
                };
                img.src = `icon-car/${file}`;
            });
        }

        // Level definitions (will be generated)
        let levels = [];
        
        function generateLevels() {
            levels = [];
            for (let i = 1; i <= 50; i++) {
                levels.push(generateLevel(i));
            }
        }
        
        function generateLevel(levelNum) {
            const difficulty = Math.min(Math.floor((levelNum - 1) / 5) + 1, 10);
            const numCars = Math.min(3 + Math.floor(levelNum / 3), 12);
            const numObstacles = Math.min(2 + Math.floor(levelNum / 4), 8);
            const numWalls = Math.min(Math.floor(levelNum / 2), 6);
            
            const cars = [];
            const obstacles = [];
            const occupiedSpaces = new Set();
            
            // Generate cars with better placement algorithm
            const availablePositions = [];
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    availablePositions.push({x, y});
                }
            }
            
            // Shuffle positions for random placement
            for (let i = availablePositions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [availablePositions[i], availablePositions[j]] = [availablePositions[j], availablePositions[i]];
            }
            
            for (let i = 0; i < numCars && availablePositions.length > 0; i++) {
                let carPlaced = false;
                
                // Try different orientations and positions
                for (let posIndex = 0; posIndex < availablePositions.length && !carPlaced; posIndex++) {
                    const pos = availablePositions[posIndex];
                    
                    // Try both orientations
                    const orientations = [
                        { width: 2, height: 1, type: 'horizontal' },
                        { width: 1, height: 2, type: 'vertical' },
                        { width: 1, height: 1, type: 'vertical' } // Single cell car
                    ];
                    
                    for (let orientation of orientations) {
                        if (pos.x + orientation.width <= GRID_WIDTH && 
                            pos.y + orientation.height <= GRID_HEIGHT) {
                            
                            const car = {
                                id: i + 1,
                                x: pos.x,
                                y: pos.y,
                                width: orientation.width,
                                height: orientation.height,
                                imageIndex: Math.floor(Math.random() * totalImages),
                                type: orientation.type
                            };
                            
                            if (!isCarOverlapping(car, cars)) {
                                cars.push(car);
                                markOccupied(car, occupiedSpaces);
                                
                                // Remove used positions
                                for (let dx = 0; dx < car.width; dx++) {
                                    for (let dy = 0; dy < car.height; dy++) {
                                        const removeIndex = availablePositions.findIndex(p => 
                                            p.x === pos.x + dx && p.y === pos.y + dy);
                                        if (removeIndex !== -1) {
                                            availablePositions.splice(removeIndex, 1);
                                        }
                                    }
                                }
                                carPlaced = true;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Generate obstacles
            for (let i = 0; i < numObstacles; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * GRID_WIDTH);
                    y = Math.floor(Math.random() * GRID_HEIGHT);
                } while (occupiedSpaces.has(`${x},${y}`));
                
                obstacles.push({
                    x: x,
                    y: y,
                    type: Math.random() > 0.5 ? 'tree' : 'barrier'
                });
                occupiedSpaces.add(`${x},${y}`);
            }
            
            // Generate walls strategically (ensure solvability)
            const exitGroups = [
                [{ x: 4, y: -1 }, { x: 5, y: -1 }], // top
                [{ x: 3, y: GRID_HEIGHT }, { x: 4, y: GRID_HEIGHT }], // bottom
                [{ x: -1, y: 3 }, { x: -1, y: 4 }], // left
                [{ x: GRID_WIDTH, y: 3 }, { x: GRID_WIDTH, y: 4 }] // right
            ];
            
            // Randomly block some exit groups but leave at least 2 open
            const groupsToBlock = Math.min(numWalls > 0 ? Math.floor(numWalls / 2) : 0, 2);
            const shuffledGroups = [...exitGroups].sort(() => Math.random() - 0.5);
            
            for (let i = 0; i < groupsToBlock; i++) {
                const group = shuffledGroups[i];
                const wallPos = group[Math.floor(Math.random() * group.length)];
                obstacles.push({
                    x: wallPos.x,
                    y: wallPos.y,
                    type: 'wall'
                });
            }
            
            // Validate that level is solvable
            if (!isLevelSolvable(cars, obstacles)) {
                // Reduce walls if level is unsolvable
                obstacles = obstacles.filter(obs => obs.type !== 'wall');
                
                // Add minimal walls that don't block all exits
                const safeWalls = [
                    { x: 4, y: -1, type: 'wall' },
                    { x: 3, y: GRID_HEIGHT, type: 'wall' }
                ];
                
                obstacles.push(...safeWalls.slice(0, Math.min(2, numWalls)));
            }
            
            return { cars, obstacles };
        }
        
        function isLevelSolvable(cars, obstacles) {
            // Check if there's at least one clear exit path
            const exits = [
                { side: 'top', positions: [{x: 4, y: -1}, {x: 5, y: -1}] },
                { side: 'bottom', positions: [{x: 3, y: GRID_HEIGHT}, {x: 4, y: GRID_HEIGHT}] },
                { side: 'left', positions: [{x: -1, y: 3}, {x: -1, y: 4}] },
                { side: 'right', positions: [{x: GRID_WIDTH, y: 3}, {x: GRID_WIDTH, y: 4}] }
            ];
            
            let openExits = 0;
            
            exits.forEach(exit => {
                const hasWall = exit.positions.some(pos => 
                    obstacles.some(obs => obs.x === pos.x && obs.y === pos.y && obs.type === 'wall')
                );
                if (!hasWall) openExits++;
            });
            
            // Need at least 2 open exits for solvability
            return openExits >= 2;
        }
        
        function isCarOverlapping(newCar, existingCars) {
            return existingCars.some(car => 
                !(newCar.x + newCar.width <= car.x || 
                  newCar.x >= car.x + car.width ||
                  newCar.y + newCar.height <= car.y || 
                  newCar.y >= car.y + car.height)
            );
        }
        
        function markOccupied(car, occupiedSpaces) {
            for (let dx = 0; dx < car.width; dx++) {
                for (let dy = 0; dy < car.height; dy++) {
                    occupiedSpaces.add(`${car.x + dx},${car.y + dy}`);
                }
            }
        }

        function initLevel() {
            if (level > levels.length) {
                alert('Selamat! Anda telah menyelesaikan semua level!');
                level = 1;
            }
            
            // Regenerate level if it seems unsolvable
            let attempts = 0;
            let currentLevel;
            do {
                currentLevel = generateLevel(level);
                attempts++;
            } while (!isLevelSolvable(currentLevel.cars, currentLevel.obstacles) && attempts < 5);
            
            cars = JSON.parse(JSON.stringify(currentLevel.cars));
            obstacles = JSON.parse(JSON.stringify(currentLevel.obstacles));
            carsExited = [];
            selectedCar = null;
            isDragging = false;
        }

        function drawBackground() {
            // Grass background
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add grass texture
            ctx.fillStyle = '#2ecc71';
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                ctx.fillRect(x, y, 2, 2);
            }

            // Parking area (asphalt)
            ctx.fillStyle = '#34495e';
            ctx.fillRect(OFFSET_X - 10, OFFSET_Y - 10, GRID_WIDTH * GRID_SIZE + 20, GRID_HEIGHT * GRID_SIZE + 20);

            // Road markings
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 8]);
            
            // Horizontal lines
            for (let y = 1; y < GRID_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(OFFSET_X, OFFSET_Y + y * GRID_SIZE);
                ctx.lineTo(OFFSET_X + GRID_WIDTH * GRID_SIZE, OFFSET_Y + y * GRID_SIZE);
                ctx.stroke();
            }
            
            // Vertical lines
            for (let x = 1; x < GRID_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(OFFSET_X + x * GRID_SIZE, OFFSET_Y);
                ctx.lineTo(OFFSET_X + x * GRID_SIZE, OFFSET_Y + GRID_HEIGHT * GRID_SIZE);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);

            // Exit areas (all sides) - green for open exits
            ctx.fillStyle = '#27ae60';
            // Top exit
            ctx.fillRect(OFFSET_X + 4 * GRID_SIZE, OFFSET_Y - 30, 2 * GRID_SIZE, 30);
            // Bottom exit
            ctx.fillRect(OFFSET_X + 3 * GRID_SIZE, OFFSET_Y + GRID_HEIGHT * GRID_SIZE, 2 * GRID_SIZE, 30);
            // Left exit
            ctx.fillRect(OFFSET_X - 30, OFFSET_Y + 2 * GRID_SIZE, 30, 2 * GRID_SIZE);
            // Right exit
            ctx.fillRect(OFFSET_X + GRID_WIDTH * GRID_SIZE, OFFSET_Y + 2 * GRID_SIZE, 30, 2 * GRID_SIZE);
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                const x = OFFSET_X + obstacle.x * GRID_SIZE;
                const y = OFFSET_Y + obstacle.y * GRID_SIZE;
                
                if (obstacle.type === 'tree') {
                    // Tree trunk
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(x + 20, y + 30, 10, 20);
                    
                    // Tree leaves
                    ctx.fillStyle = '#228b22';
                    ctx.beginPath();
                    ctx.arc(x + 25, y + 25, 20, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Tree highlight
                    ctx.fillStyle = '#32cd32';
                    ctx.beginPath();
                    ctx.arc(x + 20, y + 20, 8, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obstacle.type === 'barrier') {
                    // Traffic barrier
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(x + 10, y + 20, 30, 10);
                    
                    // Barrier stripes
                    ctx.fillStyle = '#fff';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(x + 15 + i * 8, y + 22, 4, 6);
                    }
                } else if (obstacle.type === 'wall') {
                    // Wall barrier (blocks exits)
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
                    
                    // Wall pattern
                    ctx.fillStyle = '#c0392b';
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            ctx.fillRect(x + i * 15 + 5, y + j * 15 + 5, 10, 10);
                        }
                    }
                }
            });
        }

        function drawCar(car) {
            const x = OFFSET_X + car.x * GRID_SIZE;
            const y = OFFSET_Y + car.y * GRID_SIZE;
            const width = car.width * GRID_SIZE;
            const height = car.height * GRID_SIZE;

            // Car shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(x + 2, y + 2, width, height);

            // Draw car image
            const carImg = carImages[car.imageIndex];
            if (carImg) {
                ctx.save();
                
                // Icons are vertical by default, rotate for horizontal cars
                if (car.type === 'horizontal') {
                    ctx.translate(x + width/2, y + height/2);
                    ctx.rotate(-Math.PI/2);
                    ctx.drawImage(carImg, -height/2, -width/2, height, width);
                } else {
                    ctx.drawImage(carImg, x, y, width, height);
                }
                
                ctx.restore();
            }

            // Selection outline
            if (selectedCar && selectedCar.id === car.id) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, width, height);
            }
        }

        function drawUI() {
            // Level info
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Level: ' + level, 20, 30);
            
            // Cars remaining
            ctx.font = '18px Arial';
            ctx.fillText('Mobil tersisa: ' + cars.length, 20, 55);
            ctx.fillText('Mobil keluar: ' + carsExited.length, 200, 55);
            
            // Instructions
            ctx.font = '14px Arial';
            ctx.fillText('Keluarkan semua mobil melalui pintu keluar merah', 20, canvas.height - 20);
            
            // Check win condition
            if (cars.length === 0) {
                ctx.fillStyle = '#f1c40f';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('LEVEL SELESAI!', canvas.width / 2, 40);
            }
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function getGridPos(x, y) {
            return {
                x: Math.floor((x - OFFSET_X) / GRID_SIZE),
                y: Math.floor((y - OFFSET_Y) / GRID_SIZE)
            };
        }

        function getCarAt(x, y) {
            const gridPos = getGridPos(x, y);
            return cars.find(car => 
                gridPos.x >= car.x && gridPos.x < car.x + car.width &&
                gridPos.y >= car.y && gridPos.y < car.y + car.height
            );
        }

        function isObstacleAt(x, y) {
            return obstacles.some(obstacle => obstacle.x === x && obstacle.y === y);
        }

        function canMoveCar(car, newX, newY) {
            // Allow movement outside grid for exit (but not too far)
            if (newX < -2 || newY < -2 || 
                newX > GRID_WIDTH + 1 || 
                newY > GRID_HEIGHT + 1) {
                return false;
            }

            // Check obstacles (including walls outside grid)
            for (let dx = 0; dx < car.width; dx++) {
                for (let dy = 0; dy < car.height; dy++) {
                    const checkX = newX + dx;
                    const checkY = newY + dy;
                    if (isObstacleAt(checkX, checkY)) {
                        return false;
                    }
                }
            }

            // Check collision with other cars
            for (let otherCar of cars) {
                if (otherCar.id === car.id) continue;
                
                if (!(newX + car.width <= otherCar.x || 
                      newX >= otherCar.x + otherCar.width ||
                      newY + car.height <= otherCar.y || 
                      newY >= otherCar.y + otherCar.height)) {
                    return false;
                }
            }
            
            return true;
        }

        function checkCarExit(car) {
            // Check if car reached any exit area
            if (car.y < 0 || car.y + car.height > GRID_HEIGHT ||
                car.x < 0 || car.x + car.width > GRID_WIDTH) {
                
                // Check if path to exit is blocked by walls
                let canExit = false;
                
                // Check each exit direction
                if (car.y < 0) {
                    // Top exit - check if any part can exit through non-wall area
                    for (let dx = 0; dx < car.width; dx++) {
                        if (!isObstacleAt(car.x + dx, -1)) {
                            canExit = true;
                            break;
                        }
                    }
                } else if (car.y + car.height > GRID_HEIGHT) {
                    // Bottom exit
                    for (let dx = 0; dx < car.width; dx++) {
                        if (!isObstacleAt(car.x + dx, GRID_HEIGHT)) {
                            canExit = true;
                            break;
                        }
                    }
                } else if (car.x < 0) {
                    // Left exit
                    for (let dy = 0; dy < car.height; dy++) {
                        if (!isObstacleAt(-1, car.y + dy)) {
                            canExit = true;
                            break;
                        }
                    }
                } else if (car.x + car.width > GRID_WIDTH) {
                    // Right exit
                    for (let dy = 0; dy < car.height; dy++) {
                        if (!isObstacleAt(GRID_WIDTH, car.y + dy)) {
                            canExit = true;
                            break;
                        }
                    }
                }
                
                if (canExit) {
                    // Remove car from game
                    const index = cars.findIndex(c => c.id === car.id);
                    if (index !== -1) {
                        cars.splice(index, 1);
                        carsExited.push(car);
                        playSound(660, 0.2);
                        
                        // Check win condition
                        if (cars.length === 0) {
                            setTimeout(() => {
                                level++;
                                initLevel();
                                playSound(880, 0.4);
                            }, 1500);
                        }
                    }
                    return true;
                }
            }
            return false;
        }

        function moveCar(car, newX, newY) {
            if (canMoveCar(car, newX, newY)) {
                car.x = newX;
                car.y = newY;
                playSound(440, 0.1);
                
                // Check if car exited
                checkCarExit(car);
                return true;
            }
            return false;
        }

        function playSound(frequency, duration) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {}
        }

        function gameLoop() {
            drawBackground();
            drawObstacles();
            cars.forEach(car => drawCar(car));
            drawUI();
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            const car = getCarAt(pos.x, pos.y);
            
            if (car) {
                selectedCar = car;
                isDragging = true;
                dragOffset = {
                    x: pos.x - (OFFSET_X + car.x * GRID_SIZE),
                    y: pos.y - (OFFSET_Y + car.y * GRID_SIZE)
                };
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && selectedCar) {
                const pos = getMousePos(e);
                const newGridX = Math.round((pos.x - OFFSET_X - dragOffset.x) / GRID_SIZE);
                const newGridY = Math.round((pos.y - OFFSET_Y - dragOffset.y) / GRID_SIZE);
                
                if (selectedCar.type === 'horizontal') {
                    moveCar(selectedCar, newGridX, selectedCar.y);
                } else {
                    moveCar(selectedCar, selectedCar.x, newGridY);
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            selectedCar = null;
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                initLevel();
            }
        });
        
        // Back to game selector
        document.getElementById('backToSelector').addEventListener('click', () => {
            if (window.parent !== window) {
                window.location.href = '/game/game-selector.html';
            } else {
                window.location.href = '/game/game-selector.html';
            }
        });

        // Start game
        loadCarImages();
    </script>
</body>
</html>