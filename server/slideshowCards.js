import oracledb from 'oracledb';

const dbConfig = {
  user: process.env.DB_USER || 'system',
  password: process.env.DB_PASSWORD || 'Pusd4t1n2025',
  connectString: process.env.DB_CONNECT_STRING || '10.15.38.162:1539/FREEPDB1',
};

// Create tables
const createSlideshowCardsTableSQL = `
CREATE TABLE WEBSITE_JAKHABITAT_SLIDESHOW_CARDS (
  ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  TITLE VARCHAR2(255) NOT NULL,
  DESCRIPTION CLOB,
  IMAGE_URL VARCHAR2(500) NOT NULL,
  ORDER_NUM NUMBER DEFAULT 1,
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
`;

const createSlideshowHotspotsTableSQL = `
CREATE TABLE WEBSITE_JAKHABITAT_SLIDESHOW_HOTSPOTS (
  ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  CARD_ID NUMBER NOT NULL,
  X_COORDINATE NUMBER NOT NULL,
  Y_COORDINATE NUMBER NOT NULL,
  TYPE VARCHAR2(20) DEFAULT 'link',
  LABEL VARCHAR2(255),
  HREF VARCHAR2(500),
  ICON VARCHAR2(100),
  TEXT_CONTENT VARCHAR2(255),
  ICON_URL VARCHAR2(500),
  TARGET_CARD_ID NUMBER,
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT FK_SLIDESHOW_HOTSPOT_CARD FOREIGN KEY (CARD_ID) REFERENCES WEBSITE_JAKHABITAT_SLIDESHOW_CARDS(ID) ON DELETE CASCADE
)
`;

export async function initSlideshowTables() {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    
    // Check and create slideshow cards table
    const cardsTableCheck = await connection.execute(
      `SELECT COUNT(*) as count FROM user_tables WHERE table_name = 'WEBSITE_JAKHABITAT_SLIDESHOW_CARDS'`,
      {},
      { outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    
    if (cardsTableCheck.rows[0].COUNT === 0) {
      await connection.execute(createSlideshowCardsTableSQL);
      console.log('Table WEBSITE_JAKHABITAT_SLIDESHOW_CARDS created successfully');
    }
    
    // Check and create slideshow hotspots table
    const hotspotsTableCheck = await connection.execute(
      `SELECT COUNT(*) as count FROM user_tables WHERE table_name = 'WEBSITE_JAKHABITAT_SLIDESHOW_HOTSPOTS'`,
      {},
      { outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    
    if (hotspotsTableCheck.rows[0].COUNT === 0) {
      await connection.execute(createSlideshowHotspotsTableSQL);
      console.log('Table WEBSITE_JAKHABITAT_SLIDESHOW_HOTSPOTS created successfully');
    }
  } catch (error) {
    console.error('Slideshow tables initialization error:', error);
  } finally {
    if (connection) {
      await connection.close();
    }
  }
}

// Slideshow Cards CRUD
export async function getSlideshowCards() {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    
    const result = await connection.execute(
      `SELECT ID, TITLE, DESCRIPTION, IMAGE_URL, ORDER_NUM, CREATED_AT, UPDATED_AT
       FROM WEBSITE_JAKHABITAT_SLIDESHOW_CARDS 
       ORDER BY ORDER_NUM ASC, CREATED_AT DESC`,
      {},
      { outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    
    const cards = [];
    for (const row of result.rows) {
      cards.push({
        id: Number(row.ID),
        title: String(row.TITLE || ''),
        description: String(row.DESCRIPTION || ''),
        imageUrl: String(row.IMAGE_URL || ''),
        order: Number(row.ORDER_NUM || 1),
        createdAt: row.CREATED_AT ? new Date(row.CREATED_AT).toISOString() : null,
        updatedAt: row.UPDATED_AT ? new Date(row.UPDATED_AT).toISOString() : null
      });
    }
    
    return cards;
  } catch (error) {
    throw error;
  } finally {
    if (connection) {
      await connection.close();
    }
  }
}

export async function insertSlideshowCard(cardData) {
  let connection;
  try {
    // Validate required fields
    if (!cardData.title || !cardData.imageUrl) {
      throw new Error('Title and imageUrl are required');
    }
    
    connection = await oracledb.getConnection(dbConfig);
    
    const result = await connection.execute(
      `INSERT INTO WEBSITE_JAKHABITAT_SLIDESHOW_CARDS 
       (TITLE, DESCRIPTION, IMAGE_URL, ORDER_NUM) 
       VALUES (:title, :description, :imageUrl, :orderNum)`,
      {
        title: cardData.title,
        description: cardData.description || '',
        imageUrl: cardData.imageUrl,
        orderNum: cardData.order || 1
      },
      { autoCommit: true, outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    
    return result;
  } catch (error) {
    throw error;
  } finally {
    if (connection) {
      await connection.close();
    }
  }
}

export async function updateSlideshowCard(id, cardData) {
  let connection;
  try {
    // Validate required fields
    if (!cardData.title || !cardData.imageUrl) {
      throw new Error('Title and imageUrl are required');
    }
    
    connection = await oracledb.getConnection(dbConfig);
    
    const result = await connection.execute(
      `UPDATE WEBSITE_JAKHABITAT_SLIDESHOW_CARDS 
       SET TITLE = :title, DESCRIPTION = :description, IMAGE_URL = :imageUrl, 
           ORDER_NUM = :orderNum, UPDATED_AT = CURRENT_TIMESTAMP
       WHERE ID = :id`,
      {
        id: parseInt(id),
        title: cardData.title,
        description: cardData.description || '',
        imageUrl: cardData.imageUrl,
        orderNum: cardData.order || 1
      },
      { autoCommit: true, outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    
    return result;
  } catch (error) {
    throw error;
  } finally {
    if (connection) {
      await connection.close();
    }
  }
}

export async function deleteSlideshowCard(id) {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    
    const result = await connection.execute(
      `DELETE FROM WEBSITE_JAKHABITAT_SLIDESHOW_CARDS WHERE ID = :id`,
      { id: parseInt(id) },
      { autoCommit: true, outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    
    return result;
  } catch (error) {
    throw error;
  } finally {
    if (connection) {
      await connection.close();
    }
  }
}

// Slideshow Hotspots CRUD
export async function getSlideshowHotspots(cardId) {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    
    const result = await connection.execute(
      `SELECT ID, CARD_ID, X_COORDINATE, Y_COORDINATE, TYPE, LABEL, HREF, ICON, 
              TEXT_CONTENT, ICON_URL, TARGET_CARD_ID, CREATED_AT
       FROM WEBSITE_JAKHABITAT_SLIDESHOW_HOTSPOTS 
       WHERE CARD_ID = :cardId
       ORDER BY CREATED_AT ASC`,
      { cardId: parseInt(cardId) },
      { outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    
    const hotspots = [];
    for (const row of result.rows) {
      hotspots.push({
        id: Number(row.ID),
        cardId: Number(row.CARD_ID),
        x: Number(row.X_COORDINATE),
        y: Number(row.Y_COORDINATE),
        type: String(row.TYPE || 'link'),
        label: row.LABEL ? String(row.LABEL) : null,
        href: row.HREF ? String(row.HREF) : null,
        icon: row.ICON ? String(row.ICON) : null,
        text: row.TEXT_CONTENT ? String(row.TEXT_CONTENT) : null,
        iconUrl: row.ICON_URL ? String(row.ICON_URL) : null,
        targetCardId: row.TARGET_CARD_ID ? Number(row.TARGET_CARD_ID) : null,
        createdAt: row.CREATED_AT ? new Date(row.CREATED_AT).toISOString() : null
      });
    }
    
    return hotspots;
  } catch (error) {
    throw error;
  } finally {
    if (connection) {
      await connection.close();
    }
  }
}

export async function insertSlideshowHotspot(hotspotData) {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    
    const result = await connection.execute(
      `INSERT INTO WEBSITE_JAKHABITAT_SLIDESHOW_HOTSPOTS 
       (CARD_ID, X_COORDINATE, Y_COORDINATE, TYPE, LABEL, HREF, ICON, TEXT_CONTENT, ICON_URL, TARGET_CARD_ID) 
       VALUES (:cardId, :x, :y, :type, :label, :href, :icon, :text, :iconUrl, :targetCardId)`,
      {
        cardId: hotspotData.cardId,
        x: hotspotData.x,
        y: hotspotData.y,
        type: hotspotData.type || 'link',
        label: hotspotData.label || null,
        href: hotspotData.href || null,
        icon: hotspotData.icon || null,
        text: hotspotData.text || null,
        iconUrl: hotspotData.iconUrl || null,
        targetCardId: hotspotData.targetCardId || null
      },
      { autoCommit: true, outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    
    return result;
  } catch (error) {
    throw error;
  } finally {
    if (connection) {
      await connection.close();
    }
  }
}

export async function deleteSlideshowHotspot(id) {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    
    const result = await connection.execute(
      `DELETE FROM WEBSITE_JAKHABITAT_SLIDESHOW_HOTSPOTS WHERE ID = :id`,
      { id: parseInt(id) },
      { autoCommit: true, outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    
    return result;
  } catch (error) {
    throw error;
  } finally {
    if (connection) {
      await connection.close();
    }
  }
}

// Icons management
export async function getIcons() {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    
    const result = await connection.execute(
      `SELECT ID, FILENAME, ORIGINAL_NAME, FILE_SIZE, CREATED_AT
       FROM WEBSITE_JAKHABITAT_FOTO 
       WHERE CATEGORY = 'icon'
       ORDER BY CREATED_AT DESC`,
      {},
      { outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    
    const icons = [];
    for (const row of result.rows) {
      icons.push({
        id: Number(row.ID),
        filename: String(row.FILENAME || ''),
        originalName: String(row.ORIGINAL_NAME || ''),
        fileSize: row.FILE_SIZE ? Number(row.FILE_SIZE) : null,
        createdAt: row.CREATED_AT ? new Date(row.CREATED_AT).toISOString() : null
      });
    }
    
    return icons;
  } catch (error) {
    throw error;
  } finally {
    if (connection) {
      await connection.close();
    }
  }
}

export async function deleteIcon(filename) {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    
    const result = await connection.execute(
      `DELETE FROM WEBSITE_JAKHABITAT_FOTO WHERE FILENAME = :filename AND CATEGORY = 'icon'`,
      { filename },
      { autoCommit: true, outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    
    return result;
  } catch (error) {
    throw error;
  } finally {
    if (connection) {
      await connection.close();
    }
  }
}